# 代码问题分析
## main 函数不能有数字，new 关键字无法初始化结构体中的复杂属性
结构体中只有一些基本属性可以new初始化，但下面这种不行
```go
type Param map[string]interface{}

type Show struct {
	Param
}
func main1() {
    s := new(Show)
    s.Param["RMB"] = 10000
}
```
## switch case的多类型推断问题
```go
type student struct {
	Name string
}

func zhoujielun(v interface{}) {
	switch msg := v.(type) {
	case *student, student:
		msg.Name
	}
}
```
单一类型：编译器可以确定 msg 的具体类型
多个类型：编译器无法确定 msg 到底是哪个具体类型，只能回退到 interface{}
switch 语句中，当单个 case 分支包含多个类型时，编译器无法为变量推断出具体类型，
只能将其回退到最通用的 interface{} 类型，从而导致无法直接访问具体类型的字段和方法。
## 结构体私有属性需要注意
json.Unmarshal() 无法解码结构体的私有属性，并且私有属性也不应该加上 `json:"xxx"`

## 实现接口方法时避免递归调用
例如，在实现String()方法时，如果在方法内部使用fmt.Sprintf("%v", p)格式化自身，
会导致无限递归调用，最终引发栈溢出（stack overflow）。
```go
type People struct {
	Name string
}

func (p *People) String() string {
	return fmt.Sprintf("print: %v", p)
}

func main() {
 	p := &People{}
	p.String()
}
```
fmt.Sprintf会调用类型实现的 String 接口

## 多个协程并发时，goroutine 的调度时间是不确定的，特别注意两个有联系的并发协程
```go
func main() {
	ch := make(chan int, 1000)
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
	}()
	go func() {
		for {
			a, ok := <-ch
			if !ok {
				fmt.Println("close")
				return
			}
			fmt.Println("a: ", a)
		}
	}()
	close(ch)
	fmt.Println("ok")
	time.Sleep(time.Second * 100)
}
```
两个协程调度时间不确定，第一个协程可能还没写入通道，就被第二个协程读了导致失败。
还有就是通道还没空，就被 close 了， 随后写失败导致 panic
## atomic.CompareAndSwapInt32 函数不需要循环调用。
## time.Sleep 的参数数值不可太大，不能超过 1<<63 - 1 的限制。
## defer 查 error 时，要在协程开始处调用
## map中取值时注意值类型和指针
```go
type Student struct {
	name string
}

func main() {
	m := map[string]Student{"people": {"zhoujielun"}}
	m["people"].name = "wuyanzu"
}
```
以上代码通过m["people"]直接修改属性会出错，因为m["people"]获取的是值的副本，而非访问到真实对象地址。
可以取出m["people"]对象后赋值修改后赋值回去，
也可以改成映射为指针类型 map[string]*Student{"people": {"zhoujielun"}} 。
根本原因总结：
Map元素不可寻址：Go中的map元素不能被取地址
值语义：m["people"]返回的是Student的副本，不是原始值

## 涉及多协程时，注意竞态条件
‌竞态条件‌是 多线程或并发编程中 因共享资源访问顺序不可控导致的 程序行为异常现象，其本质是多个执行单元对共享资源的非原子操作缺乏同步机制

## byte=8bit 即8个二进制位0~255
Golang 中，byte 其实被 alias 到 uint8 上了

## 十六题 GC 相关
runtime.Gosched()
runtime.GC()
golang 的 GC 动作是需要所有正在运行 goroutine 都停止后进行的。因此，程序会卡在 runtime.GC() 等待所有协程退出

## for _,v := range xx 中 v 会复用（循环赋值）
因此不可以用于取地址，地址数据会发生变化。

## runtime 包学习
## 十九题 runtime 调度相关

## golang 语言中没有继承概念，只有组合
```go
type People struct{}
func (p *People) ShowA() {
    fmt.Println("showA")
    p.ShowB()
}
func (p *People) ShowB() {
    fmt.Println("showB")
}

type Teacher struct {
    People
}
func (t *Teacher) ShowB() {
    fmt.Println("teacher showB")
}

func main() {
    t := Teacher{}
    t.ShowA()
}
```
Teacher包含了 People里所有的属性和方法。因为是组合概念，teacher 在组合了 people 后，不会覆写被组合的 People 的方法。
ShowA()中的上下文实际上是在 p 结构体中，函数内 showB 自然也用的是 p 中的 showB 方法。
如果 t.ShowB() 就直接用的是(t *Teacher) ShowB()方法

## golang 在多个case 可读的时候会公平的选中一个执行
select case中会有多个分支，他们之间没有顺序关系，而是随机选择一个执行

## **defer 在定义的时候会计算好调用函数的参数!**
```go
func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2
	defer calc("1", a, calc("10", a, b))
	a = 0
	defer calc("2", a, calc("20", a, b))
	b = 1
}
```
defer 在定义的时候会计算好调用函数的参数，所以会优先输出10、20 两个参数。然后根据定义的顺序倒序执行。
也就是先顺序计算参数函数，再倒序执行 defer 的函数

## make 在初始化切片时指定了长度，切片中会有初始值0
```go
func main() {
	s := make([]int, 5)
	s = append(s, 1, 2, 3)
	fmt.Println(s)
}
```
输出为 0 0 0 0 0 1 2 3。

